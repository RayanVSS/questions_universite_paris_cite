[
  {
    "question": "```prolog\nX is 1+1, X =:= 1+1.\n```",
    "réponse": [
      "X = 2."
    ],
    "explication": "X est évalué à 2 par l’instruction `is`. L’expression `1+1` est aussi évaluée à 2, donc la comparaison arithmétique `=:=` réussit.",
    "typing": false,
    "réponse possible": [
      "true.",
      "false.",
      "erreur",
      "X = 2.",
      "X = 1+1."
    ]
  },
  {
    "question": "```prolog\nX is 1+1, X == 1+1.\n```",
    "réponse": [
      "false."
    ],
    "explication": "`is` évalue 1+1 en 2. `==` compare les structures sans évaluation : 2 n’est pas identique à 1+1, donc false.",
    "typing": false,
    "réponse possible": [
      "true.",
      "false.",
      "erreur",
      "X = 2."
    ]
  },
  {
    "question": "```prolog\nX = 1+1, X == 1+1.\n```",
    "réponse": [
      "X = 1+1."
    ],
    "explication": "`X = 1+1` lie X à la structure 1+1. `==` compare les structures syntaxiques identiques, donc la requête réussit.",
    "typing": false,
    "réponse possible": [
      "true.",
      "false.",
      "erreur",
      "X = 1+1."
    ]
  },
  {
    "question": "```prolog\nQ =.. [member,1,[1]], Q.\n```",
    "réponse": [
      "Q = member(1,[1])."
    ],
    "explication": "Q devient `member(1,[1])`. L’appel réussit puisque 1 appartient à la liste [1].",
    "typing": false,
    "réponse possible": [
      "true.",
      "false.",
      "erreur",
      "Q = member(1,[1]).",
      "Q =  [member,1,[1]]."
    ]
  },
  {
    "question": "```prolog\nf(X,Y) =.. L, member(Z,L).\n```",
    "réponse": [
      "L = [f, X, Y], Z = f",
      "L = [f, Z, Y], X = Z",
      "L = [f, X, Z], Y = Z"
    ],
    "explication": "`=..` transforme le terme f(X,Y) en la liste [f,X,Y]. Les éléments sont explorés par `member/2`",
    "typing": false,
    "réponse possible": [
      "true.",
      "false.",
      "erreur",
      "Z = f ; Z = X ; Z = Y.",
      "L = [f, X, Y], Z = f",
      "L = [f, Z, Y], X = Z",
      "L = [f, X, Z], Y = Z"
    ]
  },
  {
    "question": "```prolog\nnot(not(false ; true)).\n```",
    "réponse": [
      "true."
    ],
    "explication": "L’intérieur `(false ; true)` réussit, donc `not(...)` échoue, et la double négation `not(not(...))` réussit.",
    "typing": false,
    "réponse possible": [
      "true.",
      "false.",
      "erreur",
      "false ; true"
    ]
  },
  {
    "question": "```prolog\nnot(not((!, false) ; true)).\n```",
    "réponse": [
      "false."
    ],
    "explication": "",
    "typing": false,
    "réponse possible": [
      "true.",
      "false.",
      "erreur",
      "false ; true"
    ]
  },
  {
    "question": "```prolog\nbagof(X, (member(X,[1,2,3,4,5]), X mod 2 =:= 1), L).\n```",
    "réponse": [
      "L = [1,3,5]."
    ],
    "explication": "`bagof/3` collecte les valeurs de X satisfaisant les conditions. Les entiers impairs de la liste sont 1,3,5.",
    "typing": false,
    "réponse possible": [
      "true.",
      "false.",
      "erreur",
      "L = [1,3,5].",
      "L = [2,4].",
      "L = 1.",
      "L = [1,2,3,4,5]."
    ]
  },
  {
    "question": "```prolog\nbagof(X, (member(X,[1,2,3,4,5]), !), L).\n```",
    "réponse": [
      "L = [1]."
    ],
    "explication": "Le cut `!` fige la première solution de `member/2`. `bagof` ne recueille donc que X=1.",
    "typing": false,
    "réponse possible": [
      "true.",
      "false.",
      "erreur",
      "L = [1].",
      "L = [1,2,3,4,5].",
      "L = 1."
    ]
  },
  {
    "question": "```prolog\n[X,a|[Y|Z]] = [1,DEUX,3,4,5].\n```",
    "réponse": [
      "DEUX = a, X = 1, Y = 3, Z = [4, 5]."
    ],
    "explication": "Unification positionnelle : X correspond au premier élément, a au second, Y au troisième, et Z au reste.",
    "typing": false,
    "réponse possible": [
      "true.",
      "false.",
      "erreur",
      "DEUX = a, X = 1, Y = 3, Z = [4, 5].",
      "DEUX = a, X = 1, Y = 3, Z = 4."
    ]
  }
]