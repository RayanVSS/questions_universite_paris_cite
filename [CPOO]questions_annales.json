[
  {
    "question": "Quand ¬´ this ¬ª appara√Æt dans une m√©thode, sa valeur est le r√©cepteur de l‚Äôappel courant √† celle-ci.",
    "r√©ponse": "Vrai",
    "explication": "NB : il y a aussi un autre usage de this, pour d√©signer un constructeur de la classe courante, lorsqu‚Äôappel√© au d√©but d‚Äôun autre constructeur de cette m√™me classe. Dans ce cas, this n‚Äôest pas une expression, donc pas d‚Äôinfluence sur la r√©ponse.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Toute classe poss√®de au moins un constructeur.",
    "r√©ponse": "Vrai",
    "explication": "Oui, au pire le compilateur ajoute le fameux ¬´ constructeur par d√©faut ¬ª (qui ne prend pas de param√®tre, et initialise les champs √† leur valeur par d√©faut, √† savoir 0 ou null).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Quand un objet n‚Äôest plus utilis√©, il faut demander √† la JVM de lib√©rer la m√©moire qu‚Äôil occupe.",
    "r√©ponse": "Faux",
    "explication": "Non, le ramasse-miettes d√©termine automatiquement quels objets ne sont plus r√©f√©renc√©s et peuvent donc √™tre lib√©r√©s (ce qu‚Äôil va donc faire p√©riodiquement sans qu‚Äôon ait √† le demander).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La ligne üî∏ du programme ci-dessous affiche ¬´ 1 ¬ª ?\n ```java\nclass Truc {\n static int v1 = 0; int v2 = 0;\n public int getV1() { return v1; }\n public int getV2() { return v2; }\n public Truc() { v1++; v2++; }\n}\n \npublic class Main {\n public static void main(String args[]) {\n  System.out.println(new Truc().getV1());\n  System.out.println(new Truc().getV2());\n  System.out.println(new Truc().getV1());üî∏\n  }\n}```\n",
    "r√©ponse": "Faux",
    "explication": "v1 et v2 n‚Äôont pas le m√™me statut. v1 est statique et donc n‚Äôexiste qu‚Äôen un seul exemplaire, incr√©ment√© √† chaque instanciation de Truc. Donc La ligne üî∏ affiche ‚Äú3‚Äù.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La ligne üî∏ du programme ci-dessous affiche ¬´ 1 ¬ª ?\n ```java\nclass Truc {\n static int v1 = 0; int v2 = 0;\n public int getV1() { return v1; }\n public int getV2() { return v2; }\n public Truc() { v1++; v2++; }\n}\n \npublic class Main {\n public static void main(String args[]) {\n  System.out.println(new Truc().getV1());\n  System.out.println(new Truc().getV2());üî∏\n  System.out.println(new Truc().getV1());\n  }\n}```\n",
    "r√©ponse": "Faux",
    "explication": " v2, elle, est un attribut d‚Äôinstance, donc un nouvel exemplaire existe pour chaque nouvelle instance de Truc, dont la valeur vaut 1 √† la sortie du constructeur. Donc la ligne üî∏ affiche ‚Äú1‚Äô",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Object est supertype de double",
    "r√©ponse": "Faux",
    "explication": "Object est un type r√©f√©rence (type de toutes les r√©f√©rences) et double est un type primitif, or les types r√©f√©rence et les types primitifs sont deux hi√©rarchies de types disjointes.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La dur√©e de vie d‚Äôun attribut statique est celle d‚Äôune instance donn√©e de la classe.",
    "r√©ponse": "Faux",
    "explication": "Non, la dur√©e de vie d‚Äôun attribut statique est li√©e √† la dur√©e d‚Äôexistence de la classe dans la m√©moire de la JVM (typiquement : toute la dur√©e de l‚Äôex√©cution du programme)",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La plateforme Java est adapt√©e √† la programmation syst√®me.",
    "r√©ponse": "Faux",
    "explication": "Les m√©thodes d‚Äôacc√®s au syst√®me fournies par l‚ÄôAPI Java sont suffisamment abstraites pour √™tre communes √† toutes les plateformes pour lesquelles il existe une impl√©mentation de la JVM. Elles ne donnent donc pas une vision assez bas niveau pour manipuler les primitives d‚Äôun syst√®me d‚Äôexploitation donn√©.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Dans un fichier source Java, une instruction se situe n√©cessairement entre une accolade ouvrante et une accolade fermante.",
    "r√©ponse": "Faux",
    "explication": "C‚Äôest principalement une question de d√©finition. Selon la JLS, les instructions (statements) sont des √©l√©ments syntaxiques qu‚Äôon peut placer dans un bloc (qui lui-m√™me est d√©limit√© par des accolades et peut aussi servir d‚Äôinstruction).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Avec x et y de type Object, apr√®s ex√©cution de l‚Äôinstruction x = y;, la variable x repr√©sente d√©sormais une copie de l'objet repr√©sent√© par y.",
    "r√©ponse": "Faux",
    "explication": "Une affectation copie seulement ce qu‚Äôil y a directement dans la variable. Pour les types r√©f√©rence comme Object, la variable contient une adresse, qui est copi√©e.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une interface peut avoir des instances directes.",
    "r√©ponse": "Faux",
    "explication": "Non, seules les classes (non abstraites) peuvent avoir des instances directes. Une interface n‚Äôa d‚Äôailleurs pas de constructeur.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Tout objet existant √† l‚Äôex√©cution est instance de Object.",
    "r√©ponse": "Vrai",
    "explication": "Object est par d√©finition le type de tous les objets‚Ä¶ et de null.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le polymorphisme par sous-typage permet de r√©utiliser une m√©thode f(...), avec des param√®tres d‚Äôeffets de types diff√©rents entre deux utilisations, sans recompiler f(...).",
    "r√©ponse": "Vrai",
    "explication": "Pour les valeurs primitives, l‚Äôappel peut √™tre pr√©c√©d√© d‚Äôune conversion comme i2f. Pour les r√©f√©rences d‚Äôobjet, l‚Äôappel se fait sans pr√©caution particuli√®re.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Il est plus facile de prouver qu‚Äôun programme se comporte correctement quand ses classes encapsulent leurs donn√©es que quand elles ne le font pas.",
    "r√©ponse": "Vrai",
    "explication": "En effet, l‚Äôencapsulation permet d‚Äôassurer qu‚Äôun membre n‚Äôest utilis√© que depuis l‚Äôint√©rieur de la classe, donc la preuve ne n√©cessite que de regarder ce qui se passe dans la classe √† valider.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Les attributs d‚Äôune interface sont tous statiques.",
    "r√©ponse": "Vrai",
    "explication": "Oui, par conception du langage. La raison est que si une interface avait des attributs d‚Äôinstance, elle forcerait ses impl√©mentations √† contenir ces donn√©es, ce qui va au del√† des pr√©ro- gatives d‚Äôune interface (√† savoir : d√©finir les int√©ractions avec les objets et non pas leur mise en ≈ìuvre)",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une classe impl√©mentant une interface doit impl√©menter/red√©finir toutes les m√©thodes d√©clar√©es dans l'interface.",
    "r√©ponse": "Faux",
    "explication": "Une classe abstraite peut impl√©menter une interface sans red√©finir toutes les m√©thodes d√©clar√©es (qui restent abstraites). De plus, les interfaces peuvent contenir des m√©thodes par d√©faut (default) ou statiques qui n'ont pas besoin d'√™tre red√©finies.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Pour faire un downcasting, on doit demander explicitement le transtypage.",
    "r√©ponse": "Vrai",
    "explication": "Le downcasting est une op√©ration potentiellement dangereuse qui n√©cessite une demande explicite. Si le transtypage √©choue √† l'ex√©cution, une exception est lev√©e.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La m√©thode somme ci-dessous s‚Äôex√©cute toujours sans erreur (exception) : ```java\nimport java.util.List; import java.util.ArrayList;\npublic class PaquetDEntiers {\n     private final List<Integer> contenu; private final int taille;\n       public PaquetDEntiers(ArrayList<Integer> contenu)\n            if (contenu != null) this.contenu = contenu\n          else this.contenu = Collections.emptyList(); // initialisation √† liste vide\n            this.taille = this.contenu.size()\n      }\n     public int somme() {\n         int s = 0; for (int i = 0; i < taille; i++) { s += contenu.get(i); } return s;\n      }\n  }```\n",
    "r√©ponse": "Faux",
    "explication": ": C‚Äôest un probl√®me d‚Äôaliasing : si on initialise une instance de PaquetDEntiers avec une liste non vide, puis qu‚Äôon supprime un √©l√©ment de la liste avant de demander √† l‚Äôinstance de PaquetDEntiers de calculer la somme, on aura IndexOutOfBoundsException : en effet, le nombre d‚Äôit√©rations pour calculer la somme est cal√© sur la taille qu‚Äôavait la liste au moment de la construction. Si la taille a √©t√© diminu√©e entre temps, le calcul de la somme va faire un appel √† get sur un indice qui n‚Äôest plus dans la liste, d‚Äôo√π l‚Äôerreur.\n Pour rendre cette classe robuste, il faut initialiser l‚Äôattribut contenu avec une copie d√©fensive du param√®tre du constructeur.\n La solution consistant √† supprimer l‚Äôattribut redondant taille et se servir de contenu.size() comme borne du for fonctionne aussi, mais seulement dans un contexte single-threaded. Dans un contexte multi-thread, en cas d‚Äôacc√®s concurrents √† la liste alias√©e, il peut encore y avoir des soucis. Cela dit, dans tous les cas de figure, c‚Äôest une bonne chose de supprimer les attributs redondants.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Java dispose d'un syst√®me de typage statique.",
    "r√©ponse": "Vrai",
    "explication": "La preuve : le compilateur refuse les programmes mal typ√©s.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le code source doit √™tre compil√© en code-octet avant chaque ex√©cution.",
    "r√©ponse": "Faux",
    "explication": "Le code-octet peut √©videmment √™tre r√©-ex√©cut√© √† volont√©.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Les objets sont typiquement stock√©s dans la pile.",
    "r√©ponse": "Faux",
    "explication": ": On aurait pu vouloir dire ‚Äútoujours‚Äù au lieu de ‚Äútypiquement‚Äù. Mais ce n‚Äôest pas tout √† fait vrai : la JVM est autoris√©e √† optimiser en stockant des objets en pile s‚Äôils sont r√©f√©renc√©s seulement localement (sans alias externe). Cette optimisation ne provoque aucune diff√©rence fonctionelle (aucune diff√©rence de comportement visible, si ce n‚Äôest la vitesse d‚Äôex√©cution).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Certaines v√©rifications de type ont lieu √† l'ex√©cution.",
    "r√©ponse": "Vrai",
    "explication": "Quelques v√©rifications √† l'ex√©cution : l'√©valuation de checkcast (instruction ajout√©e au code-octet pour les downcasting d'objet); l'√©valuation de instanceof; l'√©valuation de getClass(); l'√©valuation de invokevirtual (instruction ajout√©e au code-octet pour appeler une m√©thode d'instance afin que la JVM op√®re la liaison dynamique : choix d'une m√©thode en fonction du type de l'objet r√©cepteur).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Quand on \"cast\" (transtype) une expression d'un type r√©f√©rence vers un autre, dans certains cas, Java doit, √† l'ex√©cution, modifier l'objet r√©f√©renc√© pour le convertir.",
    "r√©ponse": "Faux",
    "explication": "Non. Le principe d'un cast d'objet, c'est \"√ßa passe ou √ßa casse\" : soit l'objet a le type demand√© et on peut l'utiliser sans modification; soit ce n'est pas le cas, et le programme quitte sur une exception (ClassCastException).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Un transtypage de r√©f√©rence se traduit toujours par une instruction sp√©cifique dans le code-octet.",
    "r√©ponse": "Faux",
    "explication": "Seulement pour le downcasting. En effet, selon le principe du \"upcasting\", la v√©rification statique du type assure que l'objet est toujours du bon type, donc la v√©rification √† l'ex√©cution est inutile, donc aucune instruction dans le code octet n'est n√©cessaire.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "On peut d√©clarer une classe non imbriqu√©e avec la visibilit√© private.",
    "r√©ponse": "Faux",
    "explication": "Seuls public et package-private sont autoris√©s. En Java, private veut dire \"priv√© pour la classe\", ce qui n'a pas de sens pour une classe non imbriqu√©e. Cela dit, on aurait pu donner un sens diff√©rent √† private en dehors de la classe, comme par exemple \"priv√© pour le fichier\" (c'est le choix du langage Kotlin, par exemple).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Dans une classe B, membre statique de A (on suppose que B ne contient pas elle-m√™me de d√©finition de type imbriqu√©e), this d√©signe toujours une instance de B.",
    "r√©ponse": "Faux",
    "explication": "this d√©signe toujours une instance de la classe \"la plus proche\" (dans l'ordre d'imbrication).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La classe d'un objet donn√© est connue et interrogeable √† l'ex√©cution.",
    "r√©ponse": "Vrai",
    "explication": "Cf. la correction de la question 25. Ces diff√©rents cas de figure fonctionnent car tout objet contient une r√©f√©rence vers l'objet-classe de sa classe.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La conversion de int vers float ne perd pas d‚Äôinformation.",
    "r√©ponse": "Faux",
    "explication": "float, utilisant 8 bits pour encoder la position de sa virgule, contient seulement 24 bits pour les chiffres significatifs du nombre (la mantisse) alors qu‚Äôun int en utilise 32. Donc n√©cessairement, certains int ne sont pas repr√©sentables en float sans arrondi (concr√®tement : la conversion efface les 8 bits de poids faible et indique que la virgule se situe 8 chiffres √† droite)",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une interface d√©finit un sous-type de Object.",
    "r√©ponse": "Vrai",
    "explication": "Oui, une interface d√©finit un type r√©f√©rence, donc sous-type de Object. Cela est coh√©rent car toutes les instances d‚Äôune interface sont des objets (instances des classes impl√©mentant l‚Äôinterface)",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une interface peut avoir une classe membre.",
    "r√©ponse": "Vrai",
    "explication": "C'est autoris√© par le langage. √Ä noter que la classe membre est alors statique. Remarque : cela permet, indirectement, de mettre des membres priv√©s dans une interface (alors que c'est interdit de le faire directement).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Java est plus ancien que C++.",
    "r√©ponse": "Faux",
    "explication": "C++ : ann√©es 80 ; Java : ann√©es 90. Cela dit, j'ai r√©alis√© que l'√¢ge de C++ n'√©tait pas dans le cours. Donc cette question est retir√©e du d√©compte des points.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le type d'une expression est calcul√© √† l'ex√©cution.",
    "r√©ponse": "Faux",
    "explication": "La notion d'expression n'a pas de sens √† l'ex√©cution : c'est un morceau de texte du programme qui n'existe plus que le code est compil√©. Il se trouve que l'expression est l'unit√© de base pour la v√©rification de type statique.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Si A et B sont des types r√©f√©rence, A est sous-type de B si et seulement si toutes les instances de A sont aussi des instances de B.",
    "r√©ponse": "Vrai",
    "explication": "Tout √† fait : la relation de sous-typage co√Øncide avec la relation d'inclusion d'ensembles (pour les ensembles qui sont des types).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le type des objets Java est d√©termin√© √† l'ex√©cution.",
    "r√©ponse": "Vrai",
    "explication": "Impossible autrement : les objets n'existent pas avant.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le type char est primitif.",
    "r√©ponse": "Vrai",
    "explication": "Il fait partie de la liste fixe des 8 types primitifs (dont le nom commence par une minuscule).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le type Object est primitif.",
    "r√©ponse": "Faux",
    "explication": "Les objets sont consid√©r√©s comme non primitifs (composites, en toute g√©n√©ralit√©).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La JVM interpr√®te du code source Java.",
    "r√©ponse": "Faux",
    "explication": "La JVM interpr√®te seulement (ou bien compile √† la vol√©e, cf. JIT) du code-octet, mais en aucun cas du code source. C'est le r√¥le du compilateur (javac) de comprendre le code source.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Quand, dans une m√©thode, on d√©finit et initialise une nouvelle variable locale avec une instruction de la forme Integer x = 12;, alors la valeur 12 est stock√©e dans le tas.",
    "r√©ponse": "Vrai",
    "explication": "Les variables locales sont stock√©es en pile, mais en l'occurrence, le type Integer n'est pas primitif, donc la valeur stock√©e en pile est une r√©f√©rence vers un objet du tas contenant la valeur 12 dans un champ.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Quand ¬´ this ¬ª appara√Æt dans une m√©thode, sa valeur est le r√©cepteur de l'appel courant √† celle-ci.",
    "r√©ponse": "Vrai",
    "explication": "NB: il y a aussi un autre usage de this, pour d√©signer un constructeur de la classe courante, lorsqu'appel√© au d√©but d'un autre constructeur de cette m√™me classe. Dans ce cas, this n'est pas une expression, donc pas d'influence sur la r√©ponse.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Toute classe poss√®de au moins un constructeur.",
    "r√©ponse": "Vrai",
    "explication": "Oui, au pire le compilateur ajoute le fameux ¬´ constructeur par d√©faut ¬ª (qui ne prend pas de param√®tre, et initialise les champs √† leur valeur par d√©faut, √† savoir 0 ou null).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Number est supertype de double.",
    "r√©ponse": "Faux",
    "explication": "Number est un type r√©f√©rence (type de toutes les r√©f√©rences) et double est un type primitif, or les types r√©f√©rence et les types primitifs sont deux hi√©rarchies de types disjointes.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Quand un objet n'est plus utilis√©, il faut demander √† la JVM de lib√©rer la m√©moire qu'il occupe.",
    "r√©ponse": "Faux",
    "explication": "Non, le ramasse-miettes d√©termine automatiquement quels objets ne sont plus r√©f√©renc√©s et peuvent donc √™tre lib√©r√©s (ce qu'il va donc faire p√©riodiquement sans qu'on ait √† le demander).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "javac prend en entr√©e un code source Java et produit, en sortie, du code-octet.",
    "r√©ponse": "Vrai",
    "explication": "En effet. Compiler le code source sous cette forme le rend ex√©cutable sur toutes les machines physiques pour lesquelles une JVM est impl√©ment√©e.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Pour s‚Äôassurer que l‚Äôappel √† getD sur une m√™me instance de A retourne toujours la m√™me valeur, il est n√©cessaire ajouter, dans le constructeur, une copie profonde du param√®tre d. (On suppose que tout est ex√©cut√© sur le m√™me thread.)\n\n 1 public class A {\n 2    private int d;\n 3    public A(int d) { this.d = d; \n 4    public int getD() { return d;\n5  }\n",
    "r√©ponse": "Faux",
    "explication": "Ce n‚Äôest pas n√©cessaire car ce param√®tre est de type primitif. Ainsi l‚Äôaffectation this.d = d est d√©j√† une copie profonde (vu que d n‚Äôa pas de ¬´ profondeur ¬ª). La remarque sur les threads a √©t√© ajout√©e parce qu‚Äôil est possible, en toute g√©n√©ralit√©, que le construc- teur et getD soient ex√©cut√©s sur des threads diff√©rents. Dans ce cas l√†, il n‚Äôy a pas de garantie que l‚Äôattribut soit d√©j√† initialis√© quand getD lit sa valeur. Pour ¬´ r√©parer ¬ª cette classe en mode multi-thrlead, il faudrait ajouter volatile devant la d√©clara- tion de d, voire, dans ce cas pr√©cis, final (qui donne la m√™me garantie de synchronisation), vu que d ne pourra plus √™tre modifi√© apr√®s son initialisation",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Quand on cast (transtype) une expression d'un type r√©f√©rence vers un autre, dans certains cas, Java doit, √† l'ex√©cution, modifier l'objet r√©f√©renc√© pour le convertir.",
    "r√©ponse": "Faux",
    "explication": "Non. Le principe d'un cast d'objet, c'est \"√ßa passe ou √ßa casse\" : soit l'objet a le type demand√© et on peut l'utiliser sans modification; soit ce n'est pas le cas, et le programme quitte sur une exception (ClassCastException).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le syst√®me de sous-typage de Java est structurel (si une interface T poss√®de toutes m√©thodes d'une autre interface U, avec des signatures compatibles, alors T est sous-type de U).",
    "r√©ponse": "Faux",
    "explication": "Non, le syst√®me de type de Java est, au contraire, nominal et d√©claratif : deux types sont le m√™me type si et seulement si ils ont le m√™me nom; un type est sous-type d'un autre s'il a √©t√© d√©clar√© en tant que tel via la clause extends ou implements (ou si c'est de base dans le langage).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La classe d'un objet donn√© est connue et interrogeable √† l'ex√©cution.",
    "r√©ponse": "Vrai",
    "explication": "Tout √† fait, tout objet contient une r√©f√©rence vers sa classe. Cela permet notamment √† instanceof et √† la liaison dynamique de fonctionner.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Si A et B sont des types r√©f√©rence, A est sous-type de B si et seulement si toutes les instances de A sont aussi des instances de B.",
    "r√©ponse": "Vrai",
    "explication": "Tout √† fait : la relation de sous-typage co√Øncide avec la relation d'inclusion d'ensembles (pour les ensembles qui sont des types).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le type byte est primitif.",
    "r√©ponse": "Vrai",
    "explication": "Il fait partie de la liste fixe des 8 types primitifs (dont le nom commence par une minuscule)",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Tout seul, le fichier A.java, ci-dessous, compile :\n```java\n public class A { final boolean a = 1; }\nclass B extends A { final boolean a = 0; }```\n",
    "r√©ponse": "Faux",
    "explication": "Il y a une incompatibilit√© de type entre les litt√©raux 0 et 1 (entiers) et le type d√©clar√© pour les variables a (boolean), donc ce programme ne compile pas. Cela dit, cela √©tait une erreur dans l'√©nonc√©. Les variables √©taient suppos√©es √™tre d√©clar√©es int. Si cela avait √©t√© le cas, la r√©ponse aurait √©t√© V avec l'explication suivante : ¬´ Si le doute portait sur le modificateur final, alors pas de probl√®me car l'initialisation dans B masque celle-ci. ¬ª Le point est donc donn√© √† tout le monde pour que ne soient p√©nalis√©s ni les √©tudiants ayant r√©pondu V en ayant compris les enjeux de la question mais en n'ayant pas vu le ¬´ pi√®ge ¬ª involontaire, ni les √©tudiants ayant r√©pondu F en ayant vu le pi√®ge, ni ceux qui n'ont pas r√©pondu pour cause de perplexit√© par rapport aux intentions de l'auteur de la question !",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Dans la classe B ci-dessous, la m√©thode f de la classe A est surcharg√©e par la m√©thode f de B :\n```java\nclass A { private static void f() {} }\nclass B extends A { private static void f() {} }```\n",
    "r√©ponse": "Faux",
    "explication": "Il n'y a surcharge en un point donn√© du programme que si plusieurs d√©finitions de m√©thode de m√™me nom existent dans le contexte courant. Or la m√©thode f de A √©tant priv√©e, n'est pas h√©rit√©e dans le contexte de B (et est de toute fa√ßon inaccessible en dehors de A).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une classe peut avoir plusieurs sous-classes directes.",
    "r√©ponse": "Vrai",
    "explication": "Sans probl√®me : l'h√©ritage est contraint seulement dans l'autre direction (une seule superclasse directe pour une classe donn√©e).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Pour les types r√©f√©rence, sous-typage implique h√©ritage.",
    "r√©ponse": "Faux",
    "explication": "Non, l'impl√©mentation d'interface, par exemple, cr√©e aussi du sous-typage.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La derni√®re version de Java est Java 12.",
    "r√©ponse": "Faux",
    "explication": "Faux, c'est Java 23",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La dur√©e de vie d‚Äôun attribut non statique est celle d‚Äôune instance donn√©e de la classe.",
    "r√©ponse": "Vrai",
    "explication": "Oui, un attribut non statique est aussi appel√© attribut d‚Äôinstance, ce qui veut dire qu‚Äôil est un constituant d‚Äôune instance donn√©e (de la classe dont il est un attribut)",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Avec x et y de type Object, apr√®s ex√©cution de l‚Äôinstruction x = y;, la variable x repr√©sente d√©sormais une copie de l‚Äôobjet repr√©sent√© par y",
    "r√©ponse": "Faux",
    "explication": "Une affectation copie seulement ce qu‚Äôil y a directement dans la variable. Pour les types r√©f√©rence comme Object, la variable contient une adresse, qui est copi√©e. Ainsi, y contiendra une adresse pointant sur le m√™me objet que x, qui n‚Äôa donc jamais √©t√© copi√© ici",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le type d'une expression est calcul√© √† l'ex√©cution.",
    "r√©ponse": "Faux",
    "explication": "Une expression est un morceau de code source. Ainsi, cette notion n'a de sens que pour le programmeur et pour le compilateur (qui, lui, calcule et v√©rifie le type des expressions : c'est le principe du typage statique), mais plus aucun sens √† l'ex√©cution.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Quand, dans une m√©thode, on d√©finit et initialise une nouvelle variable locale de type int, √† l'ex√©cution, sa valeur est stock√©e dans le tas.",
    "r√©ponse": "Faux",
    "explication": "Les variables locales sont stock√©es en pile ce qui permet de r√©cup√©rer la m√©moire quand on sort de la m√©thode (d√©cr√©mentation du pointeur de pile de la taille du frame).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Les op√©rations sur un attribut volatile sont atomiques (par rapport √† celui-ci)\n\n Op√©ration/M√©thode atomique par rapport √† un ensemble de variables : op√©ration/m√©thode dont les acc√®s, √† cet ensemble de variables, effectu√©s par une ex√©cution de celle-ci ne sont pas entrela√ßables avec les acc√®s, √† des variables du m√™me ensemble, effectu√©s par d‚Äôautres op√©rations ou m√©thodes.",
    "r√©ponse": "Faux",
    "explication": "Tout ce que volatile peut contribuer √† rendre atomique, ce sont les lectures et √©critures simples sur les types de 64 bits (long et float). Les acc√®s simples aux autres variables volatiles de tout type sont garanties atomiques. En revanche, les op√©rations en plusieurs √©tapes (par exemple une incr√©mentation) ne sont pas rendues atomiques par volatile.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Placer le mot-cl√© synchronized devant toutes les m√©thodes d'une classe les rend atomiques (par rapport aux attributs de cette classe)",
    "r√©ponse": "Faux",
    "explication": "Cela les rendrait atomiques seulement si c'√©taient les seules m√©thodes acc√©dant √† ces attributs. Donc c'est faux si les attributs ne sont pas priv√©s.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une enum peut avoir plusieurs supertypes directs.",
    "r√©ponse": "Vrai",
    "explication": "C'est en effet possible en impl√©mentant une ou des interfaces.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Tout seul, le fichier Z.java, ci-dessous, compile :\n```java\nimport java.util.function.*;\n\npublic class Z { Function<Object, Boolean> fx -> System.out.println(x); }```",
    "r√©ponse": "Faux",
    "explication": "La lambda expression donn√©e ici ne peut pas impl√©menter la m√©thode apply de Function car elle ne retourne rien et, en tout cas, certainement pas Boolean. Donc l'inf√©rence vers Function<Object, Boolean> n'est pas possible.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Les objets sont typiquement stock√©s dans la pile.",
    "r√©ponse": "Faux",
    "explication": "Non, ils sont typiquement stock√©s dans le tas. On aurait pu vouloir dire ¬´ toujours ¬ª au lieu de ¬´ typiquement ¬ª. Mais ce ne serait pas tout √† fait vrai : la JVM est autoris√©e √† optimiser en stockant des objets en pile s'ils sont r√©f√©renc√©s seulement localement (sans alias externe). Cette optimisation ne provoque aucune diff√©rence fonctionnelle (aucune diff√©rence de comportement visible, si ce n'est la vitesse d'ex√©cution).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une m√©thode ne peut pas √™tre √† la fois private et abstract.",
    "r√©ponse": "Vrai",
    "explication": "En effet, abstract demande une red√©finition, or pour red√©finir, il faut h√©riter, mais les membres private ne sont pas h√©ritables. Cette combinaison est donc absurde donc interdite par le compilateur.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Tout seul, le fichier Z.java, ci-dessous, compile :```java\nimport java.util.function.*;\npublic class Z { Consumer<Object> f = System.out::println; }```\n\n\\\\Rappel : public interface Consumer<T> { void accept(T t); }",
    "r√©ponse": "Vrai",
    "explication": "La m√©thode println ne retourne rien et peut accepter des param√®tres Object, elle peut donc servir √† impl√©menter la m√©thode accept de Consumer<Object>. Donc l‚Äôinf√©rence fonctionne ici.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Tout seul, le fichier Z.java, ci-dessous, compile (rappel : Integer √©tend Number) :\n ```java\npublic class Z<T extends Number> { static void f() { Z<Integer> w = new Z<>(); } }```",
    "r√©ponse": "Vrai",
    "explication": "Aucun souci pour contr√©tiser T par Integer, car Integer est sous-type de la borne (Number).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une classe abstract peut contenir une m√©thode final",
    "r√©ponse": "Vrai",
    "explication": "Ici, pas de contradiction. Cela veut juste dire qu‚Äôune partie de l‚Äôimpl√©mentation ne sera pas modifiable par les sous-classes.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Object[] est un supertype de Integer[].",
    "r√©ponse": "Vrai",
    "explication": "En effet, les tableaux de Java sont covariants",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le m√™me programme sera ex√©cut√© environ 2 fois plus rapidement sur un ordinateur dont le CPU (microprocesseur) a 4 c≈ìurs que sur un ordinateur dont le CPU en a 2 (toutes les autres caract√©ristiques du mat√©riel restant identiques par ailleurs).",
    "r√©ponse": "Faux",
    "explication": "Cela n‚Äôest vrai que si le programme a √©t√© con√ßu pour distribuer son travail √©quitablement sur 4 threads. Or cela n‚Äôest pas toujours possible (certains algorithmes, de par leur nature math√©matique, ne peuvent pas √™tre distribu√©s sur plusieurs threads)",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "tout seul, le fichier Z.java, ci-dessous, compile :\n```java\npublic class Z<T> {}\nclass W<Integer> extends Z<T> {}\n```",
    "r√©ponse": "Faux",
    "explication": "Ici, tout est m√©lang√©. √Ä droite du nom de la classe qu‚Äôon d√©clare (W), on ne peut mettre qu‚Äôun param√®tre qu‚Äôon introduit (Integer √©tant un nom de classe existant, il est peu probable qu‚Äôon ait voulu que ce soit le nom d‚Äôun param√®tre); √† droite du nom de la classe qu‚Äôon √©tend (Z), il faut remplacer le param√®tre par un type bien d√©fini dans le contexte (√ßa aurait pu √™tre Integer : probablement l‚Äôintention du programmeur ici, mais certainement pas T, qui n‚Äôa pas d‚Äôexistence en ce point du programme).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Appeler la m√©thode start sur une instance de Thread d√©marre un nouveau thread",
    "r√©ponse": "Vrai",
    "explication": "sur la tombe du createur de java que c'est vrai",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une classe final peut contenir une m√©thode abstract",
    "r√©ponse": "Faux",
    "explication": "Si c‚Äô√©tait le cas, il serait alors impossible d‚Äôimpl√©menter un jour cette m√©thode car on ne pourrait pas cr√©er de sous-classe. Comme c‚Äôest absurde, c‚Äôest interdit par le compilateur.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Les variables locales peuvent √™tre des variables partag√©es (entre threads)",
    "r√©ponse": "Faux",
    "explication": "Les variables locales √©tant stock√©es en pile, et chaque thread poss√©dant sa propre pile, les variables locales ne sont pas partag√©es.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La JVM interpr√®te du code source Java",
    "r√©ponse": "Faux",
    "explication": "La JVM ne comprend que le code-octet JVM. Il peut l‚Äôinterpr√©ter ou bien le compiler √† la vol√©e (¬´ JIT ¬ª) vers du code natif. C‚Äôest, au contraire, le r√¥le du compilateur (javac) de comprendre le code source Java.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "HashSet<Integer> est sous-type de Set<Integer>",
    "r√©ponse": "Vrai",
    "explication": " d‚Äôune part HashSet impl√©mente Set, d‚Äôautre part, les deux types g√©n√©riques sont ici param√©tr√©s avec le m√™me param√®tre (Integer)",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une enum peut h√©riter d'une autre enum.",
    "r√©ponse": "Faux",
    "explication": "Une enum est une classe h√©ritant d√©j√† de Enum, donc elle ne peut pas h√©riter d'une autre classe (de genre enum ou autrement). Par ailleurs, les enum sont non-extensibles (autrement que par les √©ventuelles classes-singleton imbriqu√©es g√©n√©r√©es par le compilateur pour les constantes de l'enum) car ce sont des types finis.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Deque<Integer> est sous-type de Deque<Object>.",
    "r√©ponse": "Faux",
    "explication": "Non : le param√®tre devrait √™tre identique (invariance des g√©n√©riques).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "L'instruction ci-dessous a pour effet d'afficher : **1 1**\n```java\nStream.of(1,2,3).peek(x -> System.out.print(x + \" \")).limit(1).forEach(System.out::print)```",
    "r√©ponse": "Vrai",
    "explication": "L'affichage sera 1 1 (et non 1 2 3 1) car les calculs demand√©s par les op√©rations interm√©diaires ne sont ex√©cut√©s que s'ils sont utiles pour obtenir le r√©sultat demand√© par l'op√©ration terminale (√©valuation paresseuse). Le fait que limit ait √©t√© appel√© fait que forEach ne demandera le traitement que du premier √©l√©ment du stream (c'est √† dire ¬´ 1 ¬ª). Donc le param√®tre de peek ne sera ex√©cut√© que pour cet √©l√©ment-l√†.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Dans la classe B ci-dessous, la m√©thode f d√©finie dans B masque la m√©thode f h√©rit√©e :\n```java\nclass A { private static void f() {} }\nclass B extends A { private static void f() {} }```",
    "r√©ponse": "Faux",
    "explication": "On ne peut masquer que ce qui est h√©rit√©. Or la m√©thode f de A √©tant priv√©e, n'est pas h√©rit√©e.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": " Le mot-cl√© volatile devant un attribut emp√™che les acc√®s en comp√©tition √† celui-ci",
    "r√©ponse": "Vrai",
    "explication": "pas d'explication",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "La conversion de long vers double ne perd pas d‚Äôinformation.",
    "r√©ponse": "Faux",
    "explication": ": double, utilisant 11 bits pour encoder la position de sa virgule, contient seulement 53 bits pour le signe et les chiffres significatifs du nombre (la mantisse) alors qu‚Äôun long en utilise 64. Donc n√©cessairement, certains long ne sont pas repr√©sentables en double sans arrondi (concr√®tement : la conversion efface les 11 bits de poids faible et indique que la virgule se situe 11 chiffres √† droite).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une interface peut contenir une enum membre",
    "r√©ponse": "Vrai",
    "explication": " C‚Äôest autoris√© par le langage. √Ä noter que l‚Äôenum membre est alors statique",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Quand, dans une classe, on d√©finit une m√©thode de m√™me nom qu‚Äôune m√©thode h√©rit√©e, il y a n√©cessairement masquage ou red√©finition de cette derni√®re",
    "r√©ponse": "Faux",
    "explication": "Pas forc√©ment : si la signature ne correspond pas, on est dans un cas de surcharge",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le type de l‚Äôargument de la m√©thode add d‚Äôune instance donn√©e de LinkedList est connu et interrogeable √† l‚Äôex√©cution",
    "r√©ponse": "Faux",
    "explication": " Ce type est seulement connu du compilateur, virtuellement associ√© √† l‚Äôinstance courante de LinkedList, mais oubli√© aussit√¥t la compilation termin√©e (type erasure)",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "HashSet<Integer> est sous-type de Set<Integer>.",
    "r√©ponse": "Vrai",
    "explication": "Oui : d'une part, HashSet impl√©mente Set, d'autre part, les deux types g√©n√©riques sont ici param√©tr√©s avec le m√™me param√®tre (Integer).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Deque<Integer> est sous-type de Deque<Object>.",
    "r√©ponse": "Faux",
    "explication": "Non : le param√®tre devrait √™tre identique (invariance des g√©n√©riques).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Le compilateur autorise √† d√©clarer une enum qui soit sous-type de Iterable<Boolean>.",
    "r√©ponse": "Vrai",
    "explication": "Oui, les enums, comme les classes classiques, peuvent impl√©menter n'importe quelle interface.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Une classe peut avoir plusieurs sous-classes directes.",
    "r√©ponse": "Vrai",
    "explication": "Sans probl√®me : l'h√©ritage est contraint seulement dans l'autre direction (une seule superclasse directe pour une classe donn√©e).",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Dans le programme ci-dessous, le type Livre est immuable :\n```java\n public class Livre {\n      public final String titre, auteur;\n      private Livre(String auteur, String titre) { this.auteur = auteur; this.titre = titre; }\n      public static final class Roman extends Livre {\n            public Roman(String auteur, String titre) { super(auteur, titre); }\n      }\n      public static final class Essai extends Livre {\n            public Essai(String auteur, String titre) { super(auteur, titre); }\n      }\n }\n```",
    "r√©ponse": "Vrai",
    "explication": "Correction : Ici Livre est une classe scell√©e correctement √©crite (constructeur priv√© et sous-classes finales), dont les attributs sont final et eux-m√™mes de type immuable (String). Donc toutes les instances de Livre sont garanties d‚Äô√™tre non modifiables, donc le type Livre est immuable."
  }
]