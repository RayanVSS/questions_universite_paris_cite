[
  {
    "question": "[Diapo 4] Quelle est la d√©marche pour introduire des classes abstraites ?",
    "r√©ponse": "Identifier des facteurs communs, d√©finir une interface, r√©√©crire le code",
    "explication": "La motivation est de factoriser les comportements communs derri√®re une interface.",
    "typing": false,
    "r√©ponse possible": [
      "Identifier des facteurs communs, d√©finir une interface, r√©√©crire le code",
      "Commencer par optimiser, puis profiler, puis documenter",
      "Coder sans mod√®le puis refactorer",
      "Remplacer toutes les classes par des templates"
    ]
  },
  {
    "question": "[Diapo 5] En UML, √©crire une m√©thode en italique signifie :",
    "r√©ponse": "La m√©thode est abstraite",
    "explication": "En UML, l‚Äôitalique est l‚Äôusage conventionnel pour les membres abstraits.",
    "typing": false,
    "r√©ponse possible": [
      "La m√©thode est abstraite",
      "La m√©thode est statique",
      "La m√©thode est finale",
      "La m√©thode est inline"
    ]
  },
  {
    "question": "[Diapo 6] La classe suivante est-elle abstraite ?\n```cpp\nclass AppareilDeMesure {\npublic:\n    virtual void calibrer() = 0;\n    virtual double mesurer() = 0;\n};\n``` \n",
    "r√©ponse": "Vrai",
    "explication": "La pr√©sence d'au moins une m√©thode virtuelle pure (=0) rend la classe abstraite.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "[Diapo 7] √Ä propos d‚Äôune classe abstraite en C++, cochez ce qui est vrai :",
    "r√©ponse": [
      "On peut d√©clarer des r√©f√©rences ou des pointeurs vers elle",
      "Elle n‚Äôest pas instanciable directement"
    ],
    "explication": "On manipule les abstractions via r√©f√©rences/pointeurs et on instancie des d√©riv√©es concr√®tes.",
    "typing": false,
    "r√©ponse possible": [
      "On peut d√©clarer des r√©f√©rences ou des pointeurs vers elle",
      "On peut l‚Äôinstancier directement",
      "Elle ne peut pas contenir d‚Äôattributs",
      "Elle n‚Äôest pas instanciable directement"
    ]
  },
  {
    "question": "[Diapo 8] Le ¬´ bon ¬ª choix d‚Äôabstraction est :",
    "r√©ponse": "D√©pendant du contexte et rel√®ve de la responsabilit√© du concepteur",
    "explication": "Plusieurs hi√©rarchies sont possibles selon les besoins et le domaine.",
    "typing": false,
    "r√©ponse possible": [
      "Unique et impos√© par le langage",
      "D√©pendant du contexte et rel√®ve de la responsabilit√© du concepteur",
      "Toujours la hi√©rarchie la plus profonde",
      "Toujours la hi√©rarchie la plus plate"
    ]
  },
  {
    "question": "[Diapo 9] ¬´ Plusieurs hi√©rarchies sont possibles selon le contexte ¬ª :",
    "r√©ponse": "Vrai",
    "explication": "Il n‚Äôy a pas une seule mod√©lisation correcte‚Äâ; tout d√©pend des usages cibl√©s.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "[Diapo 11] Associez la bonne s√©mantique : ¬´ = delete ¬ª sur un constructeur de copie :",
    "r√©ponse": "Interdit la copie",
    "explication": "Marquer un membre ¬´ = delete ¬ª en interdit l‚Äôusage (liage).",
    "typing": false,
    "r√©ponse possible": [
      "Impl√©mente la m√©thode par d√©faut du compilateur",
      "Interdit la copie",
      "Rend la m√©thode virtuelle pure",
      "Autorise l‚Äôh√©ritage multiple"
    ]
  },
  {
    "question": "[Diapo 11] Associez la bonne s√©mantique : ¬´ = default ¬ª sur un constructeur de copie :",
    "r√©ponse": "Impl√©mente la m√©thode par d√©faut du compilateur",
    "explication": "",
    "typing": false,
    "r√©ponse possible": [
      "Impl√©mente la m√©thode par d√©faut du compilateur",
      "Interdit la copie",
      "Rend la m√©thode virtuelle pure",
      "Autorise l‚Äôh√©ritage multiple"
    ]
  },
  {
    "question": "[Diapo 11] Associez le type : ¬´ virtual ¬ª sur un constructeur de copie :",
    "r√©ponse": "Rend la m√©thode virtuelle pure",
    "explication": "",
    "typing": false,
    "r√©ponse possible": [
      "Impl√©mente la m√©thode par d√©faut du compilateur",
      "Interdit la copie",
      "Rend la m√©thode virtuelle pure",
      "Autorise l‚Äôh√©ritage multiple"
    ]
  },
  {
    "question": "[Diapo 12] Un cas d‚Äôusage typique de ¬´ = delete ¬ª est :",
    "r√©ponse": [
      "Emp√™cher la copie (singletons, ressources uniques)",
      "Emp√™cher l‚Äôaffectation",
      "D√©sactiver certaines conversions implicites"
    ],
    "explication": "Emp√™cher la copie (singletons, ressources uniques): Emp√™cher la copie √©vite les duplications non souhait√©es d‚Äôune ressource unique.\nEmp√™cher l‚Äôaffectation: TO DO\nD√©sactiver certaines conversions implicites: TO DO",
    "typing": false,
    "r√©ponse possible": [
      "Emp√™cher la copie (singletons, ressources uniques)",
      "Emp√™cher l‚Äôaffectation",
      "D√©sactiver certaines conversions implicites",
      "Forcer la conversion implicite",
      "Acc√©l√©rer le code",
      "Rendre le destructeur noexcept"
    ]
  },
  {
    "question": "[Diapo 14] Avec une `enum` classique en C++, cochez ce qui est vrai :",
    "r√©ponse": [
      "Les identifiants sont dans le namespace englobant",
      "La conversion implicite vers `int` est possible",
      "Risque de collision de noms"
    ],
    "explication": "Les `enum` simples provoquent collisions de noms et conversions implicites.\n\n```cpp\nenum Color { Red , Green , Orange };\nenum Fruit {Pomme , Orange}; // PB\nColor c = Red; // OK\nint value = Red; // OK (= 0)\nColor d = static_cast <Color >(1);\nswitch (c) {\ncase Red:\n// ...\nbreak;\ncase Green:\n// ...\nbreak;\ndefault :\n// ...\nbreak;\n};\n```",
    "typing": false,
    "r√©ponse possible": [
      "Les identifiants sont dans le namespace englobant",
      "Les constantes restent dans un namespace d√©di√©",
      "La conversion implicite vers `int` est possible",
      "Il est impossible de faire `static_cast<int>(c)`",
      "Risque de collision de noms"
    ]
  },
  {
    "question": "[Diapo 15] Avec `enum class Color { Red, Green, Orange };` laquelle est correcte ?",
    "r√©ponse": "Color c = Color::Red;",
    "explication": "`enum class` isole les identifiants et interdit la conversion implicite vers int.",
    "typing": false,
    "r√©ponse possible": [
      "Color c = Red;",
      "Color c = Color::Red; int v = c;",
      "Color c = Color::Red;",
      "Color::Red = 0;"
    ]
  },
  {
    "question": "[Diapo 16] On veut √©crire : `if (Keyboard::isKeyPressed(Keyboard::Right)) move(Direction::Right);` Quels choix sont corrects ?",
    "r√©ponse": [
      "`Direction` peut √™tre une `enum class`",
      "`Keyboard::isKeyPressed` est une m√©thode statique d‚Äôune classe `Keyboard`"
    ],
    "explication": "`Keyboard` ne peut pas √™tre une `enum class` s‚Äôil contient une m√©thode ; l‚Äôidentifiant `Right` peut exister comme membre enum interne.",
    "typing": false,
    "r√©ponse possible": [
      "`Direction` peut √™tre une `enum class`",
      "`Keyboard` doit √™tre une `enum class`",
      "`Keyboard::isKeyPressed` est une m√©thode statique d‚Äôune classe `Keyboard`",
      "`Right` ne peut pas √™tre un identifiant de `Keyboard`"
    ]
  },
  {
    "question": "[Diapo 18] √Ä propos des classes internes en C++ : cochez ce qui est vrai.",
    "r√©ponse": [
      "Elles sont toujours d√©finies statiquement",
      "Elles ont les privil√®ges d‚Äôune classe amie vis-√†-vis de la classe englobante",
      "Pas de privil√®ges pour la classe englobante"
    ],
    "explication": "Pas d‚Äôinstance englobante √† la Java ; l‚Äôinterne a des privil√®ges d‚Äôamie.",
    "typing": false,
    "r√©ponse possible": [
      "Elles poss√®dent automatiquement une r√©f√©rence √† l‚Äôinstance englobante",
      "Elles sont toujours d√©finies statiquement",
      "Elles ont les privil√®ges d‚Äôune classe amie vis-√†-vis de la classe englobante",
      "La classe englobante a des privil√®ges sur les priv√©s de l‚Äôinterne",
      "Pas de privil√®ges pour la classe englobante"
    ]
  },
  {
    "question": "[Diapo 19] Dans le code suivant, `A::B::g(A&)` peut-elle modifier `A::n` priv√© ?\n```cpp\nclass A{\nprivate:\n  int n;\n  class B{\n  public:\n    void g(A& a);\n  };\n};\nvoid A::B::g(A& a){ a.n++; }\n```\n",
    "r√©ponse": "Oui",
    "explication": "La classe interne est consid√©r√©e comme amie et peut acc√©der aux priv√©s de A.",
    "typing": false,
    "r√©ponse possible": [
      "Oui",
      "Non"
    ]
  },
  {
    "question": "[Diapo 20] Dans ce code, pourquoi la ligne `b.x++;` est-elle invalide ?\n```cpp\nclass A{\nprivate:\n  class B{ private: int x; };\n  void f(){ B b; * b.x++; * }\n};\n```\n",
    "r√©ponse": "Parce que la classe englobante n‚Äôa pas de privil√®ges particuliers sur les membres priv√©s de la classe interne",
    "explication": "L‚Äôacc√®s est priv√© √† B, m√™me pour A qui l‚Äôenglobe.",
    "typing": false,
    "r√©ponse possible": [
      "Parce que la classe englobante n‚Äôa pas de privil√®ges particuliers sur les membres priv√©s de la classe interne",
      "Parce que `x` est `static`",
      "Parce que `x` est `const`",
      "Parce que `B` n‚Äôexiste pas pour `A`"
    ]
  },
  {
    "question": "[Diapo 22] L‚Äôobjectif des exceptions est :",
    "r√©ponse": "S√©parer le flux normal du traitement des erreurs",
    "explication": "On √©vite de m√©langer le code nominal et la gestion d‚Äôerreurs.",
    "typing": false,
    "r√©ponse possible": [
      "S√©parer le flux normal du traitement des erreurs",
      "Acc√©l√©rer syst√©matiquement le programme",
      "Remplacer les codes de retour par des `goto`",
      "Rendre tout `noexcept`"
    ]
  },
  {
    "question": "[Diapo 23] Lors d‚Äôun `throw`, quelles op√©rations ont lieu ?",
    "r√©ponse": [
      "Remont√©e de la pile des appels",
      "Destruction des objets temporaires le long de la remont√©e",
      "Recherche d‚Äôun `catch` ad√©quat"
    ],
    "explication": "C‚Äôest le m√©canisme classique d‚Äôexception et de *stack unwinding*.",
    "typing": false,
    "r√©ponse possible": [
      "Remont√©e de la pile des appels",
      "Duplication des objets existants",
      "Destruction des objets temporaires le long de la remont√©e",
      "Recherche d‚Äôun `catch` ad√©quat"
    ]
  },
  {
    "question": "[Diapo 24] Cochez ce qui est vrai concernant la syntaxe C++ des exceptions :",
    "r√©ponse": [
      "Tout type peut √™tre lanc√© en exception",
      "Les exceptions standard se trouvent dans `<stdexcept>`",
      "L‚Äôordre des `catch` est significatif"
    ],
    "explication": "Le matching se fait dans l‚Äôordre, et std propose `runtime_error`, etc.",
    "typing": false,
    "r√©ponse possible": [
      "Tout type peut √™tre lanc√© en exception",
      "On doit d√©clarer les exceptions dans la signature des m√©thodes",
      "Les exceptions standard se trouvent dans `<stdexcept>`",
      "L‚Äôordre des `catch` est significatif"
    ]
  },
  {
    "question": "[Diapo 25] Consid√©rez le bloc :\n```cpp\ntry {\n  if (condition) throw std::runtime_error{\"Description\"};\n}\ncatch (const std::runtime_error& e) {  }\ncatch (const std::exception& e) {  }\ncatch (...) {  }\n```\nLequel est pris en premier si `condition` est vraie ?",
    "r√©ponse": "Le `catch (const std::runtime_error& e)`",
    "explication": "Le premier `catch` compatible et rencontr√© est s√©lectionn√©.",
    "typing": false,
    "r√©ponse possible": [
      "Le `catch (const std::runtime_error& e)`",
      "Le `catch (const std::exception& e)`",
      "Le `catch (...)`",
      "Aucun, le programme termine"
    ]
  },
  {
    "question": "[Diapo 26] Quelle technique C++ garantit la lib√©ration de ressources en cas d‚Äôexception ?",
    "r√©ponse": "RAII (Resource Acquisition Is Initialization)",
    "explication": "Les destructeurs des objets locaux s‚Äôex√©cutent pendant le *stack unwinding*.",
    "typing": false,
    "r√©ponse possible": [
      "RAII (Resource Acquisition Is Initialization)",
      "finally obligatoire",
      "Garbage collector natif",
      "Ref counting dans `main` uniquement"
    ]
  },
  {
    "question": "[Diapo 27] Si un constructeur l√®ve une exception, le destructeur de l‚Äôobjet en construction est-il appel√© ?",
    "r√©ponse": "Non",
    "explication": "On consid√®re que l‚Äôobjet n‚Äôa jamais √©t√© construit de fa√ßon coh√©rente.",
    "typing": false,
    "r√©ponse possible": [
      "Oui",
      "Non"
    ]
  },
  {
    "question": "[Diapo 28] Consid√©rez le programme suivant. Quelle est exactement la sortie ?\n```cpp\n#include <iostream>\nusing namespace std;\nclass A { \n    public: A(){ cout<<\"A| \"; } \n    ~A(){ cout<<\"mortA| \"; } \n};\n\nclass B : \n    public A { \n        public: \n            B(){ cout<<\"B| \"; throw 1; } \n            ~B(){ cout<<\"mortB| \"; } \n        };\n\nclass C {\n    public:\n        A a; B b;\n        C(): a{}, b{} { cout<<\"C| \"; }\n        ~C(){ cout<<\"mort C| \"; }\n};\n\nint main(){ try { C c; } catch (...) { cout << \"catch| \"; } }\n\n```\n",
    "r√©ponse": "A| A| B| mortA| mortA| catch| ",
    "explication": "Ordre : construction de C.a ‚Üí A ; construction de B (h√©rite de A donc A) ‚Üí B puis throw ; on d√©truit le sous-objet A de B, puis A de C.a, puis on arrive au `catch`. (Affichage concat√©n√© : `A` (C.a), `A` (base de B), `B`, `mort A` (base de B), `mort A` (C.a), `catch`).",
    "typing": false,
    "r√©ponse possible": [
      "A| A| B| mortA| mortA| catch| ",
      "A| A| B| C| mort C| mortB| mortA| mortA|",
      "A| A| B| mortB| mortA| mortA| catch| ",
      "A| A| B| C| mort C| mortB| mortA| mortA|  catch| "
    ]
  },
  {
    "question": "[Diapo 29] Une exception lev√©e dans un destructeur pendant le *stack unwinding* est :",
    "r√©ponse": "Irrattrapable et termine le programme",
    "explication": "Pour √©viter les ¬´ doubles exceptions ¬ª, le programme se termine.",
    "typing": false,
    "r√©ponse possible": [
      "Irrattrapable et termine le programme",
      "Rattrap√©e par le `catch` le plus proche",
      "Ignor√©e silencieusement",
      "Convertie en `std::bad_alloc`"
    ]
  },
  {
    "question": "[Diapo 30] √Ä propos de `noexcept`, cochez ce qui est vrai :",
    "r√©ponse": [
      "Une exception lev√©e depuis une fonction `noexcept` provoque `std::terminate()`"
    ],
    "explication": "Le contrat `noexcept` implique la terminaison si viol√©.",
    "typing": false,
    "r√©ponse possible": [
      "Une fonction `noexcept` ne peut pas appeler d‚Äôautres fonctions",
      "Une exception lev√©e depuis une fonction `noexcept` provoque `std::terminate()`",
      "`noexcept` garantit des performances x2",
      "`noexcept` force l‚Äôinlining"
    ]
  },
  {
    "question": "[Diapo 31] Cochez les affirmations vraies sur les exceptions standard :",
    "r√©ponse": [
      "`std::exception::what()` est `noexcept`",
      "`std::invalid_argument` accepte une cha√Æne d√©crivant l‚Äôerreur"
    ],
    "explication": "Les types standards d√©rivent de `std::exception` et exposent `what()`.",
    "typing": false,
    "r√©ponse possible": [
      "`std::exception::what()` est `noexcept`",
      "`std::exception` ne peut pas √™tre instanci√©e",
      "`std::invalid_argument` accepte une cha√Æne d√©crivant l‚Äôerreur",
      "`what()` retourne un `std::string` par valeur"
    ]
  },
  {
    "question": "[Diapo 34] Dans la boucle √©v√©nementielle SFML (pour l'interface graphique), quelle m√©thode d√©pile les √©v√©nements ?",
    "r√©ponse": "app.pollEvent(event)",
    "explication": "`pollEvent` extrait les √©v√©nements en attente vers l‚Äôobjet `event` pass√© par r√©f√©rence.",
    "typing": false,
    "r√©ponse possible": [
      "app.waitEvent(event)",
      "app.pollEvent(event)",
      "app.nextEvent(event)",
      "Event::read(event)"
    ]
  },
  {
    "question": "[Diapo 35] L‚Äôappel √† `app.display()` a pour effet :",
    "r√©ponse": "Afficher effectivement le contenu rendu sur la fen√™tre",
    "explication": "Apr√®s `clear()` et les `draw()`, `display()` bascule le buffer visible.",
    "typing": false,
    "r√©ponse possible": [
      "Afficher effectivement le contenu rendu sur la fen√™tre",
      "Effacer l‚Äô√©cran",
      "Fermer la fen√™tre",
      "Bloquer jusqu‚Äôau prochain √©v√©nement"
    ]
  },
  {
    "question": "[Diapo 37] Que fait `tuile.setScale(0.5, 0.5);` ?",
    "r√©ponse": "R√©duit le sprite d‚Äôun facteur 2 sur chaque axe",
    "explication": "Un scale de 0.5 signifie une r√©duction √† 50% en X et Y.",
    "typing": false,
    "r√©ponse possible": [
      "R√©duit le sprite d‚Äôun facteur 2 sur chaque axe",
      "Augmente le sprite de 2x",
      "D√©place le sprite",
      "Change la texture"
    ]
  },
  {
    "question": "[Diapo 38] Diff√©rence principale : `Event::KeyPressed` vs `Keyboard::isKeyPressed` ?",
    "r√©ponse": "Le premier est un √©v√©nement ponctuel, le second teste un √©tat continu",
    "explication": "On traite l‚Äôinstant du d√©clenchement vs l‚Äô√©tat maintenu (utile pour d√©placements).",
    "typing": false,
    "r√©ponse possible": [
      "Le premier est un √©v√©nement ponctuel, le second teste un √©tat continu",
      "Les deux sont identiques",
      "Les deux testent un √©tat continu",
      "Aucun ne permet de lire la touche Espace"
    ]
  },
  {
    "question": "[Diapo 39] Quelle m√©thode convertit la position de la souris en coordonn√©es monde ?",
    "r√©ponse": "app.mapPixelToCoords(Mouse::getPosition(app))",
    "explication": "On transforme des pixels en coordonn√©es de la vue associ√©e √† la fen√™tre.",
    "typing": false,
    "r√©ponse possible": [
      "app.mapPixelToCoords(Mouse::getPosition(app))",
      "Mouse::getWorldPos()",
      "Keyboard::getPosition(app)",
      "Event::mousePosition()"
    ]
  },
  {
    "question": "[Diapo 42] Pourquoi introduire un pseudo Garbage Collector dans l‚Äô√©tude de cas ?",
    "r√©ponse": "Pour centraliser la destruction et √©viter des fuites dans un graphe (sommets/ar√™tes)",
    "explication": "Les objets allou√©s dynamiquement doivent √™tre lib√©r√©s de fa√ßon ordonn√©e.",
    "typing": false,
    "r√©ponse possible": [
      "Pour centraliser la destruction et √©viter des fuites dans un graphe (sommets/ar√™tes)",
      "Pour acc√©l√©rer tous les algorithmes de graphe",
      "Pour remplacer `std::unique_ptr`",
      "Pour activer un GC natif de C++"
    ]
  },
  {
    "question": "[Diapo 43] Quel patron convient pour garantir une instance unique du GC ?",
    "r√©ponse": "Singleton",
    "explication": "La diapo sugg√®re explicitement un objet unique de gestion.",
    "typing": false,
    "r√©ponse possible": [
      "Singleton",
      "Factory Method",
      "Observer",
      "Strategy"
    ]
  },
  {
    "question": "[Diapo 45] Dans `Sommet`, pourquoi appeler `Gc::add(this)` dans les constructeurs et `Gc::remove(this)` dans le destructeur ?\n\n```cpp\nclass Sommet {\n    string etiquette;\npublic:\n    Sommet(const string& s) : etiquette{s} { Gc::add(this); }\n    Sommet(const Sommet& s) : etiquette{s.etiquette} { Gc::add(this); }\n    ~Sommet () { Gc:: remove(this); }\n};\n```",
    "r√©ponse": "Pour enregistrer automatiquement les objets cr√©√©s et les d√©r√©f√©rencer √† la destruction",
    "explication": "Cela rend la gestion centralis√©e et transparente pour l‚Äôutilisateur.",
    "typing": false,
    "r√©ponse possible": [
      "Pour enregistrer automatiquement les objets cr√©√©s et les d√©r√©f√©rencer √† la destruction",
      "Pour emp√™cher toute allocation dynamique",
      "Pour activer un GC mark-and-sweep",
      "Pour s√©rialiser les sommets en JSON"
    ]
  },
  {
    "question": "[Diapo 46] Pourquoi cette impl√©mentation de destructeur de GC termine correctement ?\n```cpp\nGc::~Gc(){\n  while(!sommets.empty())\n    delete sommets.front();\n}\n``` \n",
    "r√©ponse": "Parce que `delete` d√©clenche `Sommet::~Sommet()` qui enl√®ve l‚Äô√©l√©ment de la liste, faisant progresser la boucle",
    "explication": "Le `remove` indirect via le destructeur modifie la liste, rendant la boucle finie.",
    "typing": false,
    "r√©ponse possible": [
      "Parce que `delete` d√©clenche `Sommet::~Sommet()` qui enl√®ve l‚Äô√©l√©ment de la liste, faisant progresser la boucle",
      "Parce que `front()` parcourt toute la liste",
      "Parce que `while(true)` est optimis√©",
      "Parce que `delete` ne fait rien"
    ]
  },
  {
    "question": "[Diapo 47] Quel choix de membre garantit que les extr√©mit√©s d‚Äôune ar√™te sont fix√©es d√©finitivement ?",
    "r√©ponse": "`Sommet* const depart; Sommet* const arrivee;`",
    "explication": "Le pointeur est constant (l‚Äôadresse ne change pas), ce qui fige l‚Äôextr√©mit√©.",
    "typing": false,
    "r√©ponse possible": [
      "`Sommet* const depart; Sommet* const arrivee;`",
      "`const Sommet* depart; const Sommet* arrivee;`",
      "`Sommet& depart; Sommet& arrivee;`",
      "`std::shared_ptr<Sommet> depart; std::shared_ptr<Sommet> arrivee;`"
    ]
  },
  {
    "question": "[Diapo 6] Dans la classe d√©riv√©e, l‚Äôusage de `override` est-il recommand√© ?",
    "r√©ponse": "Oui",
    "explication": "`override` permet au compilateur de v√©rifier qu‚Äôon red√©finit bien une m√©thode virtuelle existante.",
    "typing": false,
    "r√©ponse possible": [
      "Oui",
      "Non"
    ]
  },
  {
    "question": "[Diapo 14] Avec `enum` simple, choisissez les risques :",
    "r√©ponse": [
      "Collision de noms entre diff√©rentes `enum`",
      "Conversions implicites non d√©sir√©es vers `int`"
    ],
    "explication": "C‚Äôest la principale motivation pour pr√©f√©rer `enum class`.",
    "typing": false,
    "r√©ponse possible": [
      "Collision de noms entre diff√©rentes `enum`",
      "Conversions implicites non d√©sir√©es vers `int`",
      "Interdiction d‚Äôutiliser `switch`",
      "Incapacit√© √† stocker la valeur"
    ]
  },
  {
    "question": "[Diapo 24] Compl√©tez : capturer toute exception s‚Äô√©crit avec le mot cl√© ?",
    "r√©ponse": "catch",
    "explication": "on utilise `catch`, Le *catch-all* utilise l‚Äôellipse.",
    "typing": true
  },
  {
    "question": "[Diapo 33] Quels modules doivent √™tre li√©s pour une app graphique SFML minimale ? (la questions est chaud ‚Äãüî•‚Äã)",
    "r√©ponse": [
      "-lsfml-graphics",
      "-lsfml-window",
      "-lsfml-system"
    ],
    "explication": "Ce trio est l‚Äôensemble standard pour le rendu 2D, la fen√™tre et le syst√®me.",
    "typing": false,
    "r√©ponse possible": [
      "-lsfml-graphics",
      "-lsfml-window",
      "-lsfml-system",
      "-lsfml-audio"
    ]
  }
]