[
  {
    "question": "Quel est l'objectif principal des diagrammes de classes UML pr√©sent√©s dans le cours ?",
    "r√©ponse": "D√©crire les concepts pertinents et les relations entre eux",
    "explication": "Le cours souligne que l'on ne vise que les diagrammes de classes pour d√©crire les concepts pertinents et leurs relations.",
    "typing": false,
    "r√©ponse possible": [
      "D√©crire l'algorithme de chaque m√©thode",
      "G√©n√©rer automatiquement le code source complet",
      "D√©crire les concepts pertinents et les relations entre eux",
      "Mesurer la complexit√© temporelle"
    ]
  },
  {
    "question": "S√©lectionnez tous les principes qui correspondent √† ¬´ masquer les d√©tails internes non essentiels ¬ª.",
    "r√©ponse": ["Encapsulation"],
    "explication": "Encapsulation = bo√Æte noire, on masque les d√©tails internes qui ne sont pas essentiels pour l'utilisateur de l'objet.",
    "typing": false,
    "r√©ponse possible": ["Abstraction", "Encapsulation", "Modularit√©", "Hi√©rarchisation"]
  },
  {
    "question": "En UML, quelle relation exprime la d√©pendance forte o√π la destruction du compos√© entra√Æne la destruction des composants ?",
    "r√©ponse": "Composition",
    "explication": "La composition exprime une relation de vie li√©e (forte) entre le tout et les parties, contrairement √† l'agr√©gation.",
    "typing": false,
    "r√©ponse possible": ["Association", "Agr√©gation", "Composition", "H√©ritage"]
  },
  {
    "question": "Quelle est la bonne lecture d'une multiplicit√© 0..1 du c√¥t√© de la classe A dans une association binaire A‚ÄîB ?",
    "r√©ponse": "Pour toute instance fix√©e de B, il existe 0 ou 1 instance de A reli√©e",
    "explication": "La multiplicit√© contraint la taille de la collection d'instances √† l'autre extr√©mit√© lorsque l'on fixe les N‚àí1 extr√©mit√©s restantes.",
    "typing": false,
    "r√©ponse possible": [
      "Pour toute instance fix√©e de B, il existe exactement 1 instance de A reli√©e",
      "Pour toute instance fix√©e de B, il existe 0 ou 1 instance de A reli√©e",
      "A et B ont toujours le m√™me nombre d'instances",
      "Il faut au moins un lien pour toutes les combinaisons"
    ]
  },
  {
    "question": "Quel √©nonc√© est correct au sujet d'une ¬´ classe d'association ¬ª en UML ?",
    "r√©ponse": "Elle permet d'attacher des attributs ou associations √† une relation",
    "explication": "Une classe d'association porte des informations propres au lien et peut servir de point d'entr√©e vers d'autres associations.",
    "typing": false,
    "r√©ponse possible": [
      "Elle remplace toujours les associations binaires",
      "Elle emp√™che d'ajouter des multiplicit√©s",
      "Elle permet d'attacher des attributs ou associations √† une relation",
      "Elle ne peut pas porter d'attributs"
    ]
  },
  {
    "question": "En C++, quelle est la valeur nulle standard d'un pointeur moderne ?",
    "r√©ponse": "nullptr",
    "explication": "Le cours rappelle que le ¬´ z√©ro ¬ª d'un pointeur est nullptr.",
    "typing": true
  },
  {
    "question": "Dans l'expression C++ suivante, que fait l'instruction marqu√©e ?\n```cpp\nint a{0}, *pa{&a};\n*pa++; // instruction marqu√©e\n```",
    "r√©ponse": "Incr√©mente le pointeur pa (puis d√©r√©f√©rence le r√©sultat), √† cause de la priorit√© de ++ sur *",
    "explication": "++ est prioritaire sur * : on obtient (pa++), ce qui incr√©mente l'adresse stock√©e dans pa, pas la valeur de a.",
    "typing": false,
    "r√©ponse possible": [
      "Incr√©mente la valeur de a",
      "Incr√©mente le pointeur pa (puis d√©r√©f√©rence le r√©sultat), √† cause de la priorit√© de ++ sur *",
      "D√©cr√©mente a",
      "Ne compile pas"
    ]
  },
  {
    "question": "Vrai ou Faux : `int *t = new int[10]; int t2[10]; t2 = t;` est valide en C++.",
    "r√©ponse": "Faux",
    "explication": "On ne peut pas affecter √† un tableau statique une valeur de type pointeur. L'affectation `t2 = t;` est invalide.",
    "typing": false,
    "r√©ponse possible": ["Vrai", "Faux"]
  },
  {
    "question": "R√®gle de placement de `const` : il s'applique √†‚Ä¶",
    "r√©ponse": "Ce qui est imm√©diatement √† sa gauche (ou √† droite s'il n'y a rien √† gauche)",
    "explication": "C'est la r√®gle g√©n√©rale rappel√©e dans le cours.",
    "typing": false,
    "r√©ponse possible": [
      "Toujours le premier type √† droite",
      "Toujours le type de plus haut niveau",
      "Ce qui est imm√©diatement √† sa gauche (ou √† droite s'il n'y a rien √† gauche)",
      "Uniquement les pointeurs"
    ]
  },
  {
    "question": "Parmi ces d√©clarations, laquelle d√©clare un pointeur constant vers un entier non constant ?",
    "r√©ponse": "int * const p = &x;",
    "explication": "Le pointeur ne peut pas changer d'adresse (const apr√®s *), mais l'entier point√© reste modifiable.",
    "typing": false,
    "r√©ponse possible": [
      "const int * p = &x;",
      "int const * p = &x;",
      "int * const p = &x;",
      "const int * const p = &x;"
    ]
  },
  {
    "question": "√âcrivez le mot-cl√© C++ pour obtenir l'adresse d'une variable (r√©ponse libre).",
    "r√©ponse": "&",
    "explication": "L'op√©rateur unaire `&` retourne l'adresse d'une lvalue.",
    "typing": true
  },
  {
    "question": "En C++, laquelle de ces lignes lib√®re correctement un tableau allou√© dynamiquement par `new int[10]` ?",
    "r√©ponse": "delete[] p;",
    "explication": "Pour des tableaux allou√©s avec `new T[n]`, il faut `delete[] p;`.",
    "typing": false,
    "r√©ponse possible": ["delete p;", "free(p);", "delete[] p;", "dispose(p);"]
  },
  {
    "question": "quelle √©criture affiche la variable `x` du namespace `B` ?\nSupposez :\n```cpp\nnamespace A { double x{0.123}; }\nnamespace B { std::string x{\"truc\"}; }\n```",
    "r√©ponse": "std::cout << B::x;",
    "explication": "On qualifie le nom par `B::` pour acc√©der au symbole x du namespace B.",
    "typing": false,
    "r√©ponse possible": [
      "std::cout << x;",
      "std::cout << A::x;",
      "std::cout << B::x;",
      "std::cout << ::x;"
    ]
  },
  {
    "question": "Question de code (C++). √âcrivez un programme minimal qui :\\n1) alloue dynamiquement un tableau de 5 entiers,\\n2) y range 0,1,2,3,4,\\n3) affiche la somme,\\n4) lib√®re la m√©moire.\\nLa sortie attendue est : `10`",
    "r√©ponse": "10",
    "explication": "La somme de 0+1+2+3+4 = 10. Pensez √† `delete[]`.",
    "code": true,
    "language": "cpp",
    "expectedOutput": "10",
    "codeTemplate": "\n// Compl√©tez le programme\n#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    // 1) allouer un tableau dynamique de 5 entiers\n    // 2) y ranger 0..4\n    // 3) calculer la somme\n    // 4) afficher la somme puis lib√©rer\n    cout << /* somme */ << endl;\n    return 0;\n}"
  },
  {
    "question": "Consid√©rez :\n```cpp\nint *t = new int[10];\nint t2[10];\n```\nLes affectations suivantes sont-elles valides ?\nüçé `t = t2;`\nüçè `t2 = t;`",
    "r√©ponse": ["üçé‚Äã Valide", "üçè‚Äã Invalide"],
    "explication": "`t` est un pointeur et peut recevoir l'adresse d√©cay√©e de `t2`. En revanche, un tableau statique (`t2`) n'est pas assignable √† un pointeur : `t2 = t;` est ill√©gal.",
    "typing": false,
    "r√©ponse possible": ["üçé‚Äã Valide", "üçé‚Äã Invalide", "üçè‚Äã Valide", "üçè‚Äã Invalide"]
  },
  {
    "question": "D√©terminez les types :\n```cpp\nint *x[10], y[10];\n```\nS√©lectionnez les bonnes descriptions.",
    "r√©ponse": ["x est un tableau de 10 pointeurs vers int", "y est un tableau de 10 int"],
    "explication": "`x` : les crochets `[]` s'appliquent avant `*` ‚Üí tableau de pointeurs; `y` : tableau d'int.",
    "typing": false,
    "r√©ponse possible": [
      "x est un pointeur vers un tableau de 10 int",
      "x est un tableau de 10 pointeurs vers int",
      "y est un pointeur vers int",
      "y est un tableau de 10 int"
    ]
  },
  {
    "question": "R√®gle g√©n√©rale : o√π s'applique `const` ?",
    "r√©ponse": "√Ä ce qui est imm√©diatement √† sa gauche (ou √† droite s'il n'y a rien √† gauche)",
    "explication": "C'est la r√®gle rappel√©e dans le quiz : `const` lie sa protection √† l'√©l√©ment le plus proche √† gauche, par tol√©rance √† droite s'il n'y a rien √† gauche.",
    "typing": false,
    "r√©ponse possible": [
      "Toujours au premier type √† droite",
      "Uniquement aux pointeurs",
      "√Ä ce qui est imm√©diatement √† sa gauche (ou √† droite s'il n'y a rien √† gauche)",
      "Au type de plus haut niveau"
    ]
  },
  {
    "question": "```cpp\nint const a{1};\nconst int b{1};\nconst int *p{&a};\n```\nCochez les propositions valides.",
    "r√©ponse": ["p = &b;"],
    "explication": "`const int *p` : l'objet point√© est constant via `p` ‚Üí on peut changer l'adresse (`p = &b`), pas la valeur point√©e (`*p = 2` interdit).",
    "typing": false,
    "r√©ponse possible": ["p = &b; ", "*p = 2;"]
  },
  {
    "question": "```cpp\nint c{3}, d = 4.5;\nint *const q = &c;\n```\nCochez les propositions valides.",
    "r√©ponse": ["*q = 4;", "q = &c;"],
    "explication": "`int *const q` : le pointeur est constant (adresse fig√©e) mais la valeur point√©e est modifiable. On ne peut pas r√©assigner `q` vers une autre adresse.",
    "typing": false,
    "r√©ponse possible": ["*q = 4;", "q = &d;", "q = &c;", "q = &a;"]
  },
  {
    "question": "```cpp\nint const a{1};\nconst int * const r{&a};\n```\nQue peut-on faire ?",
    "r√©ponse": "Ni r√©assigner r, ni modifier *r",
    "explication": "Pointeur constant vers un entier constant : pas de changement d'adresse ni de la valeur point√©e via `r`.",
    "typing": false,
    "r√©ponse possible": [
      "R√©assigner r mais ne pas modifier *r",
      "Modifier *r mais ne pas r√©assigner r",
      "Ni r√©assigner r, ni modifier *r",
      "R√©assigner r et modifier *r"
    ]
  },
  {
    "question": "```cpp\nint b[10]={0,1,2,3,4,5,6,7,8,9};\nconst int * const x[10]{b};\n```\nQue vaut `*x[0]` juste apr√®s l'initialisation puis apr√®s `b[0]++;` ?",
    "r√©ponse": ["**juste apr√®s l'initialisation**: 0", "**Apr√®s b[0]++:**: 1"],
    "explication": "`x[0]` pointe vers `b[0]`. Le type impose des restrictions via `x`, mais la m√©moire sous-jacente `b[0]` a bien √©t√© incr√©ment√©e ‚Üí la lecture via `x` refl√®te la nouvelle valeur.",
    "typing": false,
    "r√©ponse possible": ["**juste apr√®s l'initialisation**: 0", "**juste apr√®s l'initialisation**: 1", "**Apr√®s b[0]++:**: 0", "**Apr√®s b[0]++:**: 1"]
  },
  {
    "question": "```cpp\nint *x[10], y[10], z{4};\nx[1] = &z;\ny[1] = 2*z;\n```\nQue vaut `*x[1]` ?",
    "r√©ponse": "4",
    "explication": "`x[1]` pointe vers `z` (qui vaut 4). L'affectation `y[1] = 2*z` ne modifie pas `z`. Donc `x[1] == 4`. ",
    "typing": false,
    "r√©ponse possible": ["0", "2", "4", "8"]
  },
  {
    "question": "\n```cpp\nint *x[10], y[10];\n```\nLaquelle est vraie ?",
    "r√©ponse": "`**x` d√©r√©f√©rence `x[0]` puis l'entier point√©, √©quivalent √† `*x[0]` si `x[0]` est non nul",
    "explication": "",
    "typing": false,
    "r√©ponse possible": [
      "`**x` est toujours √©gal √† `y[0]`",
      "`**x` d√©r√©f√©rence `x[0]` puis l'entier point√©, √©quivalent √† `*x[0]` si `x[0]` est non nul",
      "`**x` est l'adresse de `x`",
      "`**x` ne compile jamais"
    ]
  },
  {
    "question": "Priorit√© des op√©rateurs : lequel a la priorit√© la plus haute ?",
    "r√©ponse": "Les crochets `[]` ont priorit√© sur `*`",
    "explication": "Le quiz insiste sur la priorit√© de `[]` sur `*`, d'o√π les confusions fr√©quentes sur les types et d√©r√©f√©rencements. ",
    "typing": false,
    "r√©ponse possible": [
      "`*` a priorit√© sur `[]`",
      "Les crochets `[]` ont priorit√© sur `*`",
      "M√™me priorit√©, associativit√© √† gauche",
      "Cela d√©pend du compilateur"
    ]
  },
  {
    "question": "pour lib√©rer la m√©moire d'un tableau allou√© par `new int[10]`, que faut-il utiliser ?",
    "r√©ponse": "delete[]",
    "explication": "Les tableaux allou√©s avec `new T[n]` doivent √™tre lib√©r√©s avec `delete[]`.",
    "typing": true
  }
]